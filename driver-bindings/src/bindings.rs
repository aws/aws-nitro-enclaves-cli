/* automatically generated by rust-bindgen 0.62.0 */

pub const NE_ERR_VCPU_ALREADY_USED: u32 = 256;
pub const NE_ERR_VCPU_NOT_IN_CPU_POOL: u32 = 257;
pub const NE_ERR_VCPU_INVALID_CPU_CORE: u32 = 258;
pub const NE_ERR_INVALID_MEM_REGION_SIZE: u32 = 259;
pub const NE_ERR_INVALID_MEM_REGION_ADDR: u32 = 260;
pub const NE_ERR_UNALIGNED_MEM_REGION_ADDR: u32 = 261;
pub const NE_ERR_MEM_REGION_ALREADY_USED: u32 = 262;
pub const NE_ERR_MEM_NOT_HUGE_PAGE: u32 = 263;
pub const NE_ERR_MEM_DIFFERENT_NUMA_NODE: u32 = 264;
pub const NE_ERR_MEM_MAX_REGIONS: u32 = 265;
pub const NE_ERR_NO_MEM_REGIONS_ADDED: u32 = 266;
pub const NE_ERR_NO_VCPUS_ADDED: u32 = 267;
pub const NE_ERR_ENCLAVE_MEM_MIN_SIZE: u32 = 268;
pub const NE_ERR_FULL_CORES_NOT_USED: u32 = 269;
pub const NE_ERR_NOT_IN_INIT_STATE: u32 = 270;
pub const NE_ERR_INVALID_VCPU: u32 = 271;
pub const NE_ERR_NO_CPUS_AVAIL_IN_POOL: u32 = 272;
pub const NE_ERR_INVALID_PAGE_SIZE: u32 = 273;
pub const NE_ERR_INVALID_FLAG_VALUE: u32 = 274;
pub const NE_ERR_INVALID_ENCLAVE_CID: u32 = 275;
pub type __u64 = ::std::os::raw::c_ulonglong;
#[doc = " struct ne_image_load_info - Info necessary for in-memory enclave image"]
#[doc = "\t\t\t       loading (in / out)."]
#[doc = " @flags:\t\tFlags to determine the enclave image type"]
#[doc = "\t\t\t(e.g. Enclave Image Format - EIF) (in)."]
#[doc = " @memory_offset:\tOffset in enclave memory where to start placing the"]
#[doc = "\t\t\tenclave image (out)."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ne_image_load_info {
    pub flags: __u64,
    pub memory_offset: __u64,
}
#[test]
fn bindgen_test_layout_ne_image_load_info() {
    const UNINIT: ::std::mem::MaybeUninit<ne_image_load_info> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ne_image_load_info>(),
        16usize,
        concat!("Size of: ", stringify!(ne_image_load_info))
    );
    assert_eq!(
        ::std::mem::align_of::<ne_image_load_info>(),
        8usize,
        concat!("Alignment of ", stringify!(ne_image_load_info))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ne_image_load_info),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).memory_offset) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ne_image_load_info),
            "::",
            stringify!(memory_offset)
        )
    );
}
#[doc = " struct ne_user_memory_region - Memory region to be set for an enclave (in)."]
#[doc = " @flags:\t\tFlags to determine the usage for the memory region (in)."]
#[doc = " @memory_size:\tThe size, in bytes, of the memory region to be set for"]
#[doc = "\t\t\tan enclave (in)."]
#[doc = " @userspace_addr:\tThe start address of the userspace allocated memory of"]
#[doc = "\t\t\tthe memory region to set for an enclave (in)."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ne_user_memory_region {
    pub flags: __u64,
    pub memory_size: __u64,
    pub userspace_addr: __u64,
}
#[test]
fn bindgen_test_layout_ne_user_memory_region() {
    const UNINIT: ::std::mem::MaybeUninit<ne_user_memory_region> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ne_user_memory_region>(),
        24usize,
        concat!("Size of: ", stringify!(ne_user_memory_region))
    );
    assert_eq!(
        ::std::mem::align_of::<ne_user_memory_region>(),
        8usize,
        concat!("Alignment of ", stringify!(ne_user_memory_region))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ne_user_memory_region),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).memory_size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ne_user_memory_region),
            "::",
            stringify!(memory_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).userspace_addr) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ne_user_memory_region),
            "::",
            stringify!(userspace_addr)
        )
    );
}
#[doc = " struct ne_enclave_start_info - Setup info necessary for enclave start (in / out)."]
#[doc = " @flags:\t\tFlags for the enclave to start with (e.g. debug mode) (in)."]
#[doc = " @enclave_cid:\tContext ID (CID) for the enclave vsock device. If 0 as"]
#[doc = "\t\t\tinput, the CID is autogenerated by the hypervisor and"]
#[doc = "\t\t\treturned back as output by the driver (in / out)."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ne_enclave_start_info {
    pub flags: __u64,
    pub enclave_cid: __u64,
}
#[test]
fn bindgen_test_layout_ne_enclave_start_info() {
    const UNINIT: ::std::mem::MaybeUninit<ne_enclave_start_info> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ne_enclave_start_info>(),
        16usize,
        concat!("Size of: ", stringify!(ne_enclave_start_info))
    );
    assert_eq!(
        ::std::mem::align_of::<ne_enclave_start_info>(),
        8usize,
        concat!("Alignment of ", stringify!(ne_enclave_start_info))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ne_enclave_start_info),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).enclave_cid) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ne_enclave_start_info),
            "::",
            stringify!(enclave_cid)
        )
    );
}
